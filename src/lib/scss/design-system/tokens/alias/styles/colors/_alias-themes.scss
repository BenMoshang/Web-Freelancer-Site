// Themes/_themes.scss
// Define theme-based variables for light and dark modes

@use '../../_primitive-colors' as colors;
@use 'sass:map';
@use 'sass:meta';
@use '../../../utils/utils-functions' as utils;

/**
 * Light theme color palette
 * Maps semantic color categories to specific color values
 */
$light-theme: (
	'background': (
		'primary': colors.$color-white,
		'secondary': map.get(colors.$color-gray, 50),
		'tertiary': map.get(colors.$color-gray, 100)
	),
	'text': (
		'primary': map.get(colors.$color-gray, 900),
		'secondary': map.get(colors.$color-gray, 700),
		'tertiary': map.get(colors.$color-gray, 600),
		'disabled': map.get(colors.$color-gray, 400)
	),
	'border': (
		'default': map.get(colors.$color-gray, 200),
		'focus': map.get(colors.$color-blue, 500),
		'hover': map.get(colors.$color-gray, 300)
	),
	'accent': (
		'primary': map.get(colors.$color-blue, 500),
		'secondary': map.get(colors.$color-blue, 600),
		'tertiary': map.get(colors.$color-blue, 700)
	),
	'status': (
		'success': map.get(colors.$color-green, 500),
		'warning': map.get(colors.$color-yellow, 500),
		'error': map.get(colors.$color-red, 500),
		'info': map.get(colors.$color-blue, 500)
	)
);

/**
 * Dark theme color palette
 * Maps semantic color categories to specific color values optimized for dark mode
 */
$dark-theme: (
	'background': (
		'primary': map.get(colors.$color-gray, 950),
		'secondary': map.get(colors.$color-gray, 900),
		'tertiary': map.get(colors.$color-gray, 800)
	),
	'text': (
		'primary': colors.$color-white,
		'secondary': map.get(colors.$color-gray, 300),
		'tertiary': map.get(colors.$color-gray, 400),
		'disabled': map.get(colors.$color-gray, 600)
	),
	'border': (
		'default': map.get(colors.$color-gray, 700),
		'focus': map.get(colors.$color-blue, 400),
		'hover': map.get(colors.$color-gray, 600)
	),
	'accent': (
		'primary': map.get(colors.$color-blue, 400),
		'secondary': map.get(colors.$color-blue, 300),
		'tertiary': map.get(colors.$color-blue, 200)
	),
	'status': (
		'success': map.get(colors.$color-green, 400),
		'warning': map.get(colors.$color-yellow, 400),
		'error': map.get(colors.$color-red, 400),
		'info': map.get(colors.$color-blue, 400)
	)
);

/**
 * High-contrast theme for accessibility
 * Provides maximum contrast for better readability
 */
$high-contrast-theme: (
	'background': (
		'primary': colors.$color-black,
		'secondary': map.get(colors.$color-gray, 900),
		'tertiary': map.get(colors.$color-gray, 800)
	),
	'text': (
		'primary': colors.$color-white,
		'secondary': colors.$color-white,
		'tertiary': map.get(colors.$color-gray, 200),
		'disabled': map.get(colors.$color-gray, 400)
	),
	'border': (
		'default': colors.$color-white,
		'focus': map.get(colors.$color-yellow, 400),
		'hover': map.get(colors.$color-yellow, 300)
	),
	'accent': (
		'primary': map.get(colors.$color-yellow, 400),
		'secondary': map.get(colors.$color-yellow, 300),
		'tertiary': map.get(colors.$color-yellow, 200)
	),
	'status': (
		'success': map.get(colors.$color-green, 300),
		'warning': map.get(colors.$color-yellow, 300),
		'error': map.get(colors.$color-red, 300),
		'info': map.get(colors.$color-blue, 300)
	)
);

/**
 * Theme registry for storing all available themes
 */
$theme-registry: (
	'light': $light-theme,
	'dark': $dark-theme,
	'high-contrast': $high-contrast-theme
) !default;

/**
 * Default theme setting
 * Can be overridden when imported
 */
$current-theme: $dark-theme !default;
$fallback-theme: $light-theme !default;

/**
 * Register a new theme in the theme registry
 * @param {String} $name - Name of the theme
 * @param {Map} $theme - Theme map containing color values
 * @return {Boolean} True if registration was successful
 */
@function register-theme($name, $theme) {
	@if map.has-key($theme-registry, $name) {
		@warn "Theme '#{$name}' already exists in the registry. Use update-theme() to modify it.";
		@return false;
	}

	$theme-registry: map.merge(
		$theme-registry,
		(
			$name: $theme
		)
	) !global;

	@return true;
}

/**
 * Update an existing theme in the registry
 * @param {String} $name - Name of the theme to update
 * @param {Map} $theme - New theme values
 * @return {Boolean} True if update was successful
 */
@function update-theme($name, $theme) {
	@if not map.has-key($theme-registry, $name) {
		@warn "Theme '#{$name}' does not exist in the registry. Use register-theme() to add it.";
		@return false;
	}

	$theme-registry: map.merge(
		$theme-registry,
		(
			$name: $theme
		)
	) !global;

	@return true;
}

/**
 * Get a theme from the registry by name
 * @param {String} $name - Name of the theme to retrieve
 * @return {Map} The requested theme or the fallback theme
 */
@function get-theme($name) {
	@if map.has-key($theme-registry, $name) {
		@return map.get($theme-registry, $name);
	}

	@warn "Theme '#{$name}' not found in registry. Using fallback theme.";
	@return $fallback-theme;
}

/**
 * Function to retrieve theme values from CSS custom properties
 * with fallback options for better cross-browser compatibility
 * 
 * @param {String} $category - The category of the theme value (e.g., 'background', 'text')
 * @param {String} $key - The specific key within the category (e.g., 'primary', 'secondary')
 * @param {Map} $fallback-map - Optional map to use for fallback values
 * @return {String} CSS custom property reference with fallback
 */
@function get-theme-value($category, $key, $fallback-map: $fallback-theme) {
	// First try to get from the fallback map to provide a concrete value as fallback
	$fallback-value: null;

	@if meta.type-of($fallback-map) == map and map.has-key($fallback-map, $category) {
		$category-map: map.get($fallback-map, $category);

		@if meta.type-of($category-map) == map and map.has-key($category-map, $key) {
			$fallback-value: map.get($category-map, $key);
		}
	}

	@if $fallback-value {
		@return var(--theme-#{$category}-#{$key}, #{$fallback-value});
	} @else {
		@return var(--theme-#{$category}-#{$key});
	}
}

/**
 * Simplified theme function for easy access to theme values
 * @param {String} $category - The category of the theme value (e.g., 'background', 'text')
 * @param {String} $key - The specific key within the category (e.g., 'primary', 'secondary')
 * @return {String} CSS custom property reference with fallback
 */
@function theme($category, $key) {
	@return get-theme-value($category, $key);
}

/**
 * Mixin to apply theme-specific styles
 * Handles both user preference (prefers-color-scheme) and explicit theme selection
 * @param {String} $theme-name - The theme to apply ('light', 'dark', or custom theme name)
 * @content Styles to apply within the theme context
 */
@mixin apply-theme($theme-name) {
	@if $theme-name == 'light' {
		@media (prefers-color-scheme: light) {
			:root:not([data-theme='dark']):not([data-theme='high-contrast']) {
				@content;
			}
		}
		[data-theme='light'] {
			@content;
		}
	} @else if $theme-name == 'dark' {
		@media (prefers-color-scheme: dark) {
			:root:not([data-theme='light']):not([data-theme='high-contrast']) {
				@content;
			}
		}
		[data-theme='dark'] {
			@content;
		}
	} @else {
		[data-theme='#{$theme-name}'] {
			@content;
		}
	}
}

/**
 * Mixin to export theme variables as CSS custom properties
 * Makes theme values available throughout the application
 * @example
 * @include export-theme-variables();
 */
@mixin export-theme-variables() {
	:root {
		// Set light theme as default
		@each $category, $values in $light-theme {
			@each $key, $value in $values {
				--theme-#{$category}-#{$key}: #{$value};
			}
		}
	}

	// Dark theme variables
	@include apply-theme('dark') {
		@each $category, $values in $dark-theme {
			@each $key, $value in $values {
				--theme-#{$category}-#{$key}: #{$value};
			}
		}
	}

	// High contrast theme variables
	@include apply-theme('high-contrast') {
		@each $category, $values in $high-contrast-theme {
			@each $key, $value in $values {
				--theme-#{$category}-#{$key}: #{$value};
			}
		}
	}

	// Export any custom themes from the registry
	@each $theme-name, $theme-values in $theme-registry {
		// Skip built-in themes that we've already handled
		@if $theme-name != 'light' and $theme-name != 'dark' and $theme-name != 'high-contrast' {
			@include apply-theme($theme-name) {
				@each $category, $values in $theme-values {
					@each $key, $value in $values {
						--theme-#{$category}-#{$key}: #{$value};
					}
				}
			}
		}
	}
}

/**
 * Mixin for applying adaptive colors using CSS variables
 * @param {String} $property - CSS property to set (default: color)
 * @param {String} $category - Theme category (e.g., 'background', 'text')
 * @param {String} $key - Specific key within the category (e.g., 'primary')
 */
@mixin apply-adaptive-color($property: color, $category, $key) {
	#{$property}: var(--theme-#{$category}-#{$key});
}

/**
 * Alternative adaptive color mixin with direct values
 * Useful when you need to specify exact values rather than theme tokens
 * @param {String} $property - CSS property to set
 * @param {*} $light-value - Value to use in light theme
 * @param {*} $dark-value - Value to use in dark theme
 * @param {*} $high-contrast-value - Value to use in high contrast theme (optional)
 */
@mixin apply-adaptive-value($property, $light-value, $dark-value, $high-contrast-value: null) {
	#{$property}: $light-value;

	@include apply-theme('dark') {
		#{$property}: $dark-value;
	}

	@if $high-contrast-value {
		@include apply-theme('high-contrast') {
			#{$property}: $high-contrast-value;
		}
	}
}

/**
 * High contrast theme mixin for accessibility
 * Applies styles only when high-contrast theme is active
 * @content Styles to apply in high contrast mode
 */
@mixin high-contrast-theme {
	[data-theme='high-contrast'] {
		@content;
	}
}

/**
 * Check if a theme contains all required keys and categories
 * @param {Map} $theme - Theme to validate
 * @return {Boolean} True if theme is valid
 */
@function validate-theme($theme) {
	$required-categories: ('background', 'text', 'border', 'accent', 'status');
	$is-valid: true;

	@each $category in $required-categories {
		@if not map.has-key($theme, $category) {
			@warn "Theme validation failed: Missing required category '#{$category}'";
			$is-valid: false;
		}
	}

	@return $is-valid;
}
